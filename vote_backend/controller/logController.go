package controller

import (
	"encoding/json"
	"fmt"
	"os"
	"strconv"
	"vote_backend/models"
	"vote_backend/utils"

	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

//var Transactions = make(map[string]models.Transaction)

func AppendToLeader(newVote models.Transaction) {

	transactionData, err3 := json.Marshal(newVote)
	if err3 != nil {
		panic(err3)
	}

	fmt.Println("Writing to db" + fmt.Sprintf("%+v", newVote))
	database, err := gorm.Open(sqlite.Open("nodeDB.sql"), &gorm.Config{})
	if err != nil {
		panic(err)
	}
	//commit to log.json file
	PersistLog(newVote)

	//decrease leader log counter to match map size
	//verify the transactions...call  a vote verification function, return bool
	//ensure that the txid is valid, and was generated by an official client app
	//ensure that the node id is valid
	//ensure that the candidate id is valid
	//ensure that the vote hash is valid
	//ensure that the voter exists and that the voters details hash matches the stored hash in atleast half the nodes on the network
	//ensure that the voter hasnt already voted
	//insert verified transaction into db
	database.Create(&newVote)

	token := Client[0].Publish("followerAppend/1", 0, false, transactionData)
	token.Wait()
}

func PersistLog(newVote models.Transaction) {
	data, err := json.MarshalIndent(newVote, "", " ")
	if err != nil {
		panic(err)
	}
	logFile, err := os.OpenFile("log.json", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		panic(err)
	}

	defer logFile.Close()
	check_file, err2 := os.Stat("log.json")
	if err2 != nil {
		panic(err2)
	}
	if check_file.Size() == 0 {
		_, err3 := logFile.WriteString("[" + "\n" + string(data) + "\n" + "]")
		if err3 != nil {
			panic(err3)
		}
	} else {
		// read the file into an array of structs
		file, err4 := os.ReadFile("log.json")
		if err4 != nil {
			panic(err4)
		}

		var logsTransactions []models.Transaction

		err5 := json.Unmarshal(file, &logsTransactions)
		if err5 != nil {
			panic(err5)
		}

		// add the new block to the array
		logsTransactions = append(logsTransactions, newVote)
		data, err6 := json.MarshalIndent(logsTransactions, "", " ")
		if err6 != nil {
			panic(err6)
		}

		// delete the file
		err7 := os.Remove("log.json")
		if err7 != nil {
			panic(err7)
		} else {
			fmt.Println("File deleted")
		}
		// recreate the file
		newFile, err8 := os.OpenFile("log.json", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		if err8 != nil {
			panic(err8)
		}
		defer newFile.Close()

		// write to the file
		_, err9 := newFile.WriteString("\n" + string(data) + "\n")
		if err9 != nil {
			panic(err9)
		}
	}

}

func NodeSync() {
	fmt.Println("Leader status:" + strconv.FormatBool(LeaderAlive))
	if LeaderAlive && utils.GetClientState() != "leader" {

		utils.SetRaftState("syncing")
		token := Client[0].Publish("leaderLogRequest/1", 0, false, "requesting leader log")
		token.Wait()
	}

}
